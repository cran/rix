<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>a - Getting started</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">a - Getting started</h1>



<div id="non-technical-intro-to-nix" class="section level2">
<h2>Non-technical intro to Nix</h2>
<p><em>If you are familiar with the concept of package managers, you can
skip to the next section.</em></p>
<p>To ensure that a project is reproducible you need to deal with at
least four things:</p>
<ul>
<li>Make sure that the required/correct version of R (or any other
language) is installed;</li>
<li>Make sure that the required versions of packages are installed;</li>
<li>Make sure that system dependencies are installed (for example, you’d
need a working Java installation to install the <code>{rJava}</code> R
package on Linux);</li>
<li>Make sure that you can install all of this for the hardware you have
on hand.</li>
</ul>
<p>For the three first bullet points, the consensus seems to be a
mixture of Docker to deal with system dependencies, <code>{renv}</code>
for the packages (or <code>{groundhog}</code>, or a fixed CRAN snapshot
like those <a href="https://packagemanager.posit.co/__docs__/user/get-repo-url/#ui-frozen-urls">Posit
provides</a>) and the <a href="https://github.com/r-lib/rig">R
installation manager</a> to install the correct version of R (unless you
use a Docker image as base that already ships the required version by
default). As for the last point, the only way out is to be able to
compile the software for the target architecture. There’s a lot of
moving pieces, and knowledge that you need to have to get it right.</p>
<p>But it turns out that this is not the only solution. Docker +
<code>{renv}</code> (or some other way to deal with packages) is likely
the most popular way to ensure reproducibility of your projects, but
there are other tools to achieve this. One such tool is called Nix.</p>
<p>Nix is a package manager for Linux distributions, macOS and it even
works on Windows if you enable WSL2. What’s a package manager? If you’re
not a Linux user, you may not be aware. Let me explain it this way: in
R, if you want to install a package to provide some functionality not
included with a vanilla installation of R, you’d run this:</p>
<pre><code>install.packages(&quot;dplyr&quot;)</code></pre>
<p>It turns out that Linux distributions, like Ubuntu for example, work
in a similar way, but for software that you’d usually install using an
installer (at least on Windows). For example you could install Firefox
on Ubuntu using:</p>
<pre><code>sudo apt-get install firefox</code></pre>
<p>(there’s also graphical interfaces that make this process “more
user-friendly”). In Linux jargon, <code>packages</code> are simply what
we call software (or I guess it’s all “apps” these days). These packages
get downloaded from so-called repositories (think of CRAN, the
repository of R packages) but for any type of software that you might
need to make your computer work: web browsers, office suites, multimedia
software and so on.</p>
<p>So Nix is just another package manager that you can use to install
software.</p>
<p>But what interests us is not using Nix to install Firefox, but
instead to install R and the R packages that we require for our analysis
(or any other programming language that we need). But why use Nix
instead of the usual ways to install software on our operating
systems?</p>
<p>The first thing that you should know is that Nix’s repository,
<code>nixpkgs</code>, is huge. Humongously huge. As I’m writing these
lines, <a href="https://search.nixos.org/packages">there’s more than
100’000 pieces of software available</a>, and the <em>entirety of
CRAN</em> is also available through <code>nixpkgs</code>. So instead of
installing R as you usually do and then use
<code>install.packages()</code> to install packages, you could use Nix
to handle everything. But still, why use Nix at all?</p>
<p>Nix has an interesting feature: using Nix, it is possible to install
software in (relatively) isolated environments. So using Nix, you can
install as many versions of R and R packages that you need. Suppose that
you start working on a new project. As you start the project, with Nix,
you would install a project-specific version of R and R packages that
you would only use for that particular project. If you switch projects,
you’d switch versions of R and R packages.</p>
<p>If you are familiar with <code>{renv}</code>, you should see that
this is exactly the same thing: the difference is that not only will you
have a project-specific library of R packages, you will also have a
project-specific R version. So if you start a project now, you’d have R
version 4.2.3 installed (the latest version available in
<code>nixpkgs</code> but not the latest version available, more on this
later), with the accompagnying versions of R packages, for as long as
the project lives (which can be a long time). If you start a project
next year, then that project will have its own R, maybe R version 4.4.2
or something like that, and the set of required R packages that would be
current at that time. This is because Nix always installs the software
that you need in separate, (isolated) environments on your computer. So
you can define an environment for one specific project.</p>
<p>But Nix goes even further: not only can you install R and R packages
using Nix (in isolated) project-specific environments, Nix even installs
the required system dependencies. So for example if I need
<code>{rJava}</code>, Nix will make sure to install the correct version
of Java as well, always in that project-specific environment (so if you
already some Java version installed on your system, there won’t be any
interference).</p>
<p>What’s also pretty awesome, is that you can use a specific version of
<code>nixpkgs</code> to <em>always</em> get <em>exactly</em> the same
versions of <strong>all</strong> the software whenever you build that
environment to run your project’s code. The environment gets defined in
a simple plain-text file, and anyone using that file to build the
environment will get exactly, byte by byte, the same environment as you
when you initially started the project. And this also regardless of the
operating system that is used.</p>
</div>
<div id="the-nix-package-manager" class="section level2">
<h2>The Nix package manager</h2>
<p>Nix is a package manager that can be installed on your computer
(regardless of OS) and can be used to install software like with any
other package manager. If you’re familiar with the Ubuntu Linux
distribution, you likely have used <code>apt-get</code> to install
software. On macOS, you may have used <code>homebrew</code> for similar
purposes. Nix functions in a similar way, but has many advantages over
classic package managers. The main advantage of Nix, at least for our
purposes, is that its repository of software is huge. As of writing, it
contains more than 100.000 packages, and the entirety of CRAN and
Bioconductor is available through Nix’s repositories.</p>
<p>This means that using Nix, it is possible to install not only R, but
also all the packages required for your project. The obvious question is
why use Nix instead of simply installing R and R packages as usual. The
answer is that Nix makes sure to install every dependency of any
package, up to required system libraries. For example, the
<code>{xlsx}</code> package requires the Java programming language to be
installed on your computer to successfully install. This can be
difficult to achieve, and <code>{xlsx}</code> bullied many R developers
throughout the years (especially those using a Linux distribution,
<code>sudo R CMD javareconf</code> still plagues my nightmares).</p>
<p>But with Nix, it suffices to declare that we want the
<code>{xlsx}</code> package for our project, and Nix figures out
automatically that Java is required and installs and configures it. It
all just happens without any required intervention from the user. The
second advantage of Nix is that it is possible to <em>pin</em> a certain
<em>revision</em> of the Nix packages’ repository (called
<code>nixpkgs</code>) for our project. Pinning a revision ensures that
every package that Nix installs will always be at exactly the same
versions, regardless of when in the future the packages get
installed.</p>
<div id="other-nixes" class="section level3">
<h3>Other “Nix”es</h3>
<p>There are several implementations of the Nix package manager that you
might want to try if you’re feeling adventurous… for now, we recommend
to stick with Nix.</p>
<p>You can give <a href="https://lix.systems/install/">Lix</a> a try, or
<a href="https://tvix.dev/">Tvix</a>.</p>
</div>
</div>
<div id="rix-workflow" class="section level2">
<h2>rix workflow</h2>
<p>The idea of <code>{rix}</code> is for you to declare the environment
you need using the provided <code>rix()</code> function.
<code>rix()</code> is the package’s main function and generates a file
called <code>default.nix</code> which is then used by the Nix package
manager to build that environment. Ideally, you would set up such an
environment for each of your projects. You can then use this environment
to either work interactively, or run R scripts. It is possible to have
as many environments as projects, and software that is common to
environments will simply be re-used and not get re-installed to save
space. Environments are isolated for each other, but can still interact
with your system’s files, unlike with Docker where a volume must be
mounted. Environments can also interact with the software installed on
your computer through the usual means, which can sometimes lead to
issues. For example, if you already have R installed, and a user library
of R packages, more caution is required to properly use environments
managed by Nix.</p>
<p>It is important at this stage to understand that you should not call
<code>install.packages()</code> from a running Nix environment. If you
want to add packages to a Nix environment while analyzing data, you need
to add it the <code>default.nix</code> expression and rebuild the
environment. This is explained in greater detail in
<code>vignette(&quot;d1-installing-r-packages-in-a-nix-environment&quot;)</code>.</p>
<p>To avoid interference between your main R library of packages and
your Nix environments, calling <code>rix()</code> will also run
<code>rix_init()</code>, which will create a custom
<code>.Rprofile</code> in the project’s directory. This
<code>.Rprofile</code> will ensure that if you have a user library of
packages, these won’t get loaded by an R version running in a Nix shell.
It will also redefine <code>install.packages()</code> to throw an error
if you try to use it.</p>
<p><code>rix()</code> has several arguments:</p>
<ul>
<li>the R version you need for your project;</li>
<li>a list of R packages that your project needs;</li>
<li>an optional list of additional software (for example a Python
interpreter, or Quarto);</li>
<li>an optional list with packages to install from Github;</li>
<li>an optional list of local packages in <code>.tar.gz</code> format to
install;</li>
<li>an optional list of LaTeX packages;</li>
<li>whether you want to use RStudio as an IDE for your project (or VS
Code, or another environment);</li>
<li>the path to save the <code>default.nix</code> file (by default the
current working directory)</li>
</ul>
<p>For example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">rix</span>(</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="at">r_ver =</span> <span class="st">&quot;latest&quot;</span>,</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="at">r_pkgs =</span> <span class="fu">c</span>(<span class="st">&quot;dplyr&quot;</span>, <span class="st">&quot;chronicler&quot;</span>),</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="at">ide =</span> <span class="st">&quot;other&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>)</span></code></pre></div>
<p>The call above writes a <code>default.nix</code> file in the current
working directory. This <code>default.nix</code> can in turn be used by
Nix to build an environment containing the latest version of R, with the
<code>{dplyr}</code> and <code>{chronicler}</code> packages.</p>
<p>Take note of the <code>ide = &quot;other&quot;</code> argument: this argument,
and the values it can take, are further discussed in the vignette
<code>vignette(&quot;e-interactive-use&quot;)</code> but continue reading this
vignette and then vignettes numbered by a “d”.</p>
<div id="using-default.nix-files" class="section level3">
<h3>Using default.nix files</h3>
<p>The Nix package manager can be used to build reproducible development
environments according to the specifications found in the generated
<code>default.nix</code> files, which contain a Nix <em>expression</em>.
An <em>expression</em> is Nix jargon for a function with multiple inputs
and one output, this output being our development environment.
<code>{rix}</code> does not require Nix to be installed to generate
valid expressions (but does require an internet connection), so you
could generate expressions and use them on other machines. To actually
build an environment using a <code>default.nix</code> file, go to where
you chose to write it (ideally in a new, empty folder that will be the
root folder of your project) and use the Nix package manager to build
the environment. Call the following function in a terminal:</p>
<pre><code>nix-build</code></pre>
<p>Nix install packages in a dedicated folder on your computer, called
the <em>Nix store</em>.</p>
<p>Once Nix is done building the environment, you can start working on
it interactively by using the following command in a terminal emulator
(not the R console):</p>
<pre><code>nix-shell</code></pre>
<p>You will <em>drop</em> into a Nix shell which provides the installed
software. It is not mandatory to call <code>nix-build</code> first: you
can immediately call <code>nix-shell</code>. The advantage of using
<code>nix-build</code> first is that it create a file called
<code>result</code> which will prevent the environment to get garbage
collected if you clean the Nix store.</p>
<p>If you want to build an environment for an older version of R, you
might get a warning telling you that you cannot build the expression,
but that you can directly drop into it.</p>
<p>If you want to completely isolate your Nix environment from the rest
of the system, we recommend using <code>nix-shell --pure</code> to drop
into the environment, as described in the documentation of
<code>rix_init()</code>.</p>
<p>Finally, if you want to delete an environment, delete the
<code>result</code> file first (if you used <code>nix-build</code>) and
then call <code>nix-store --gc</code>, which will delete all the
orphaned packages.</p>
<p>Now that you know more about Nix and <code>{rix}</code>, it is time
to get these tools installed on your system.</p>
<ul>
<li>If you’re running either Linux or Windows, read the Linux or Windows
vignette:
<code>vignette(&quot;b1-setting-up-and-using-rix-on-linux-and-windows&quot;)</code></li>
<li>If you’re running macOS, read the macOS vignette:
<code>vignette(&quot;b2-setting-up-and-using-rix-on-macos&quot;)</code></li>
</ul>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
